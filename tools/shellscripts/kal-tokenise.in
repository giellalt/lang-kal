#!/usr/bin/env perl
# -*- mode: cperl; indent-tabs-mode: nil; tab-width: 3; cperl-indent-level: 3; -*-
use strict;
use warnings;
use utf8;
use FileHandle;
use IPC::Open2;

BEGIN {
	$| = 1;
	binmode(STDIN, ':encoding(UTF-8)');
	binmode(STDOUT, ':encoding(UTF-8)');
}
use open qw( :encoding(UTF-8) :std );
use feature 'unicode_strings';

use Getopt::Long;
Getopt::Long::Configure('no_ignore_case');
my $opt_fst = 0;
my $opt_verbose = 0;
my $rop = GetOptions(
	'fst|f' => \$opt_fst,
	'verbose|v' => \$opt_verbose,
                    );

my $prefix = '@prefix@';
my @fsts = ('', "@datarootdir@/giella/@GTLANG@/tokeniser-disamb-gt-desc.pmhfst", '/usr/local/share/giella/@GTLANG@/tokeniser-disamb-gt-desc.pmhfst', '/usr/share/giella/@GTLANG@/tokeniser-disamb-gt-desc.pmhfst');
if (defined $ARGV[0] && -s $ARGV[0]) {
   $fsts[0] = $ARGV[0];
}
my $fst = '';
foreach my $f (@fsts) {
   if ($f && -s $f && -r $f) {
      $fst = $f;
      last;
   }
}

if (!$fst || !-s $fst) {
   die("No usable tokeniser.pmhfst given or found!\n");
}
if ($opt_verbose) {
   print STDERR "kal-tokenise: Using ${fst}\n";
}

my $t = "hfst-tokenize -L ${fst}";

# Prefixes from root.lexc ca. lines 14-15
my @p = ('AA', 'TA');

# Main POS tags from root.lexc ca. lines 19-29
my @m = ('N', 'V', 'Pali', 'Conj', 'Adv', 'Interj', 'Pron', 'Prop', 'Num');

# Other POS tags from root.lexc ca. lines 114-180
my @a = (
   'Sg', 'Du', 'Pl',
   'Abs', 'Rel', 'Trm', 'Abl', 'Lok', 'Aeq', 'Ins', 'Via',
   'Nom', 'Akk',
   'Ind', 'Int', 'Imp', 'Opt', 'Cau', 'Con', 'Par', 'Cont', 'ContNeg', 'IteCau',
   '1Sg', '2Sg', '3Sg', '4Sg', '1Pl', '2Pl', '3Pl', '4Pl', '1Du', '2Du', '3Du', '4Du',
   '1SgO', '2SgO', '3SgO', '4SgO', '1PlO', '2PlO', '3PlO', '4PlO', '1DuO', '2DuO', '3DuO', '4DuO',
   '1SgPoss', '2SgPoss', '3SgPoss', '4SgPoss', '1PlPoss', '2PlPoss', '3PlPoss', '4PlPoss',
   );

my $pp = join('|', @p);
my $mp = join('|', @m);
my $ap = join('|', @a);
my $i = 'i';

open2(*OUT, *IN, $t) or die $!;
binmode(OUT, ':encoding(UTF-8)');
binmode(IN, ':encoding(UTF-8)');
autoflush OUT 1;
autoflush IN 1;

sub analyze {
   my ($in,$n) = @_;
   if (!$n) {
      $n = 0;
   }

   # Give up trying to make sense of input at this point...
   if ($n >= 3) {
      return $in;
   }

   my $nonce = '<nonce-'.rand().'>';
   print IN "$in\n$nonce\n";
   my $out = '';
   while ($out !~ /\Q$nonce\E/) {
      $out .= <OUT>;
   }
   $out =~ s@\Q$nonce\E\s*@@sg;

   # Work around HFST bug where abbreviations without space after are misanalyzed
   my $seen = '';
   my $did = 1;
   while ($did) {
      $did = 0;
      my @ms = ($out =~ m@^.*("<.+?>"\n.+?(?:Gram/Abbr|\?)\n\.).*(?:$seen)@sg);
      if (!@ms) {
         # Work around HFST bug that happens WITHOUT hyperminimisation
         @ms = ($out =~ m@^.*("<.+?>"\n.+?(?:Gram/Abbr|\?)\n"<\.>"\n\t"\." CLB).*(?:$seen)@sg);
      }
      foreach my $f (@ms) {
         my ($w) = ($f =~ /"<(.+?)>"/);

         $seen = "$w.*$seen";
         $did = 1;

         $w .= '.';
         my $m = analyze($w, $n + 1);
         if ($f ne $m && $m =~ /\t/) {
            $out =~ s/\Q$f\E\n/$m/s;
         }
      }
   }

   # Remove null analysis from tokens to let later steps retry them in pieces
   foreach my $f ($out =~ /(?:^|\n)("<[^\n]+?>"\n\t"[^\n]+?" \?)(?:\n|$)/g) {
      my ($wf) = ($f =~ /"<([^\n]+?)>"/);
      if ($wf =~ /^(.*?)([^\pL\pN\pM]+)(.*)$/) {
         $out =~ s/\Q$f\E\n/$wf\n/g;
      }
   }

   # Work around HFST bug by recursing un-analyzed chunks
   foreach my $f ($out =~ /(?:^|\n)([^<"\t\n][^\n]*)(?:\n|$)/g) {
      if ($f =~ /^([^\pL\pN\pM]+)(.+?)([^\pL\pN\pM]+)$/ || $f =~ /^([\pL\pN\pM]+)([^\pL\pN\pM]+)([\pL\pN\pM]+)$/) {
         # Split non-alphanumeric from alphanumeric and retry them separately
         my ($f1,$f2,$f3) = ($1, $2, $3);
         my $m1 = analyze($f1, $n + 1);
         my $m2 = analyze($f2, $n + 1);
         my $m3 = analyze($f3, $n + 1);
         if ($f1 ne $m1 || $f2 ne $m2 || $f3 ne $m3) {
            my $m = "$m1\n$m2\n$m3";
            $m =~ s/\n\n+/\n/g;
            $out =~ s/(^|\n)\Q$f\E(\n|$)/$1$m$2/g;
         }
      }
      elsif ($f =~ /^([^\pL\pN\pM]+)(.+)$/ || $f =~ /^(.+?)([^\pL\pN\pM]+)$/) {
         # Split non-alphanumeric from alphanumeric and retry them separately
         my ($f1,$f2) = ($1, $2);
         my $m1 = analyze($f1, $n + 1);
         my $m2 = analyze($f2, $n + 1);
         if ($f1 ne $m1 || $f2 ne $m2) {
            my $m = "$m1\n$m2";
            $m =~ s/\n\n+/\n/g;
            $out =~ s/(^|\n)\Q$f\E(\n|$)/$1$m$2/g;
         }
      }
      else {
         my $m = analyze($f, $n + 1);
         if ($f ne $m) {
            $out =~ s/(^|\n)\Q$f\E(\n|$)/$1$m$2/g;
         }
      }
   }

   # Work around HFST bug by recursing un-analyzed punctuation
   foreach my $f ($out =~ /(?:^|\n)([^\n\pL\pN\pM]+)(?:\n|$)/g) {
      if ($f =~ /^"<.+?>"$/) {
         next;
      }
      my $m = analyze($f, $n + 1);
      if ($f ne $m) {
         $out =~ s/(^|\n)\Q$f\E(\n|$)/$1$m$2/g;
      }
   }

   return $out;
}

my $wf = '';
while (<STDIN>) {
   my $out = analyze($_);

   foreach my $f ($out =~ /(?:^|\n)([^<"\t\n][^\n]*)(?:\n|$)/g) {
      if ($opt_verbose) {
         print STDERR "kal-tokenise: Could not analyse: ${f}\n";
      }
      $out =~ s/(^|\n)([^<"\t\n][^\n]*)(\n|$)/$1"<$2>"\n\t"$2" ?$3/;
   }

   my @ls = split(/\n+/, $out);
   foreach (@ls) {
      if ($opt_fst) {
         if (m@^"<(.+)>"@) {
            # Store wordform for later
            $wf = $1;
            print "\n";
            next;
         }
         elsif (m@^\s+"([^"]+)"@ || m@^\s+(?:$pp) "([^"]+)"@) {
            # Turn CG back into FST, protecting baseforms with spaces
            my $b = $1;
            s/^\s+//g;
            s/"\Q$b\E"/XBASEFORMX/;
            s/\s+/+/g;
            s/XBASEFORMX/$b/;
            # Prepend previously seen wordform
            $_ = "$wf\t$_";
         }
      }
      elsif (m@^\s+"@ || m@^\s+($pp) "@) {
         # Move prefixes after the base form
         s@^(\s+)($pp) (".+?" )@$1$3Prefix/$2 @;
         # Mark all internal POS tags so they don't confuse the later steps
         while (s@ ($mp|$ap)( .+ (?:$mp))@ $i$1$2@g) {}
      }
      print "$_\n";
   }
}
