#!/usr/bin/env perl
# -*- mode: cperl; indent-tabs-mode: nil; tab-width: 3; cperl-indent-level: 3; -*-
use strict;
use warnings;
use utf8;
use FileHandle;
use IPC::Open2;

BEGIN {
	$| = 1;
	binmode(STDIN, ':encoding(UTF-8)');
	binmode(STDOUT, ':encoding(UTF-8)');
}
use open qw( :encoding(UTF-8) :std );
use feature 'unicode_strings';

use Getopt::Long;
Getopt::Long::Configure('no_ignore_case');
my $opt_bin = '';
my $opt_fst = 0;
my $opt_verbose = 0;
my $rop = GetOptions(
	'bin|b=s' => \$opt_bin,
	'fst|f' => \$opt_fst,
	'verbose|v' => \$opt_verbose,
                    );

my @bins = ($opt_bin, '/usr/local/bin/hfst-tokenise', '/opt/local/bin/hfst-tokenise', '/usr/bin/hfst-tokenise');
my $bin = '';
foreach my $f (@bins) {
   if ($f && -x $f) {
      $bin = $f;
      last;
   }
}
if (!$bin || !-x $bin) {
   die("No usable hfst-tokenise given or found!\n");
}
if ($opt_verbose) {
   print STDERR "kal-tokenise: Using ${bin}\n";
}

my $prefix = '@prefix@';
my @fsts = ('', "@datarootdir@/giella/@GTLANG@/tokeniser-disamb-gt-desc.pmhfst", '/usr/local/share/giella/@GTLANG@/tokeniser-disamb-gt-desc.pmhfst', '/usr/share/giella/@GTLANG@/tokeniser-disamb-gt-desc.pmhfst');
if (defined $ARGV[0] && -s $ARGV[0]) {
   $fsts[0] = $ARGV[0];
}
my $fst = '';
foreach my $f (@fsts) {
   if ($f && -s $f && -r $f) {
      $fst = $f;
      last;
   }
}

if (!$fst || !-s $fst) {
   die("No usable tokeniser.pmhfst given or found!\n");
}
if ($opt_verbose) {
   print STDERR "kal-tokenise: Using ${fst}\n";
}

my $t = "${bin} -L ${fst}";

# Prefixes from root.lexc ca. lines 14-15
my @p = ('AA', 'TA');

# Main POS tags from root.lexc ca. lines 19-29
my @m = ('N', 'V', 'Pali', 'Conj', 'Adv', 'Interj', 'Pron', 'Prop', 'Num');

# Other POS tags from root.lexc ca. lines 114-180
my @a = (
   'Sg', 'Du', 'Pl',
   'Abs', 'Rel', 'Trm', 'Abl', 'Lok', 'Aeq', 'Ins', 'Via',
   'Nom', 'Akk',
   'Ind', 'Int', 'Imp', 'Opt', 'Cau', 'Con', 'Par', 'Cont', 'ContNeg', 'IteCau',
   '1Sg', '2Sg', '3Sg', '4Sg', '1Pl', '2Pl', '3Pl', '4Pl', '1Du', '2Du', '3Du', '4Du',
   '1SgO', '2SgO', '3SgO', '4SgO', '1PlO', '2PlO', '3PlO', '4PlO', '1DuO', '2DuO', '3DuO', '4DuO',
   '1SgPoss', '2SgPoss', '3SgPoss', '4SgPoss', '1PlPoss', '2PlPoss', '3PlPoss', '4PlPoss',
   );

my $pp = join('|', @p);
my $mp = join('|', @m);
my $ap = join('|', @a);
my $i = 'i';

open2(*OUT, *IN, $t) or die $!;
binmode(OUT, ':encoding(UTF-8)');
binmode(IN, ':encoding(UTF-8)');
autoflush OUT 1;
autoflush IN 1;

my %cache = ();

sub call_tokenizer {
   my ($in) = @_;

   my $out = '';
   if (defined $cache{$in}) {
      $out = $cache{$in};
   }
   else {
      my $nonce = '<nonce-'.rand().'>';
      print IN "$in\n$nonce\n";
      while ($out !~ /\Q$nonce\E/) {
         $out .= <OUT>;
      }
      $out =~ s@\Q$nonce\E\s*@@sg;

      # Move prefixes after the base form
      $out =~ s@^(\s+)($pp) (".+?" )@$1$3Prefix/$2 @mg;

      # Special case +URL
      $out =~ s/"\+URL/" URL/g;

      # Remove empty lines, because they were simply spaces in the input
      # $out =~ s/\n([\s\t]*\n)+/\n/g; # HANDLE BETTER

      if ($in !~ /\s/) {
         $cache{$in} = $out;
      }
   }

   return $out;
}

sub parse_cohorts {
   my ($out) = @_;

   my @cs = ();
   my $in_c = 0;
   my $last = 0;
   # Parse hfst-tokenize's output to array of cohorts
   foreach (split(/\n+/, $out)) {
      my $f = $_;
      s/\s+$//g;

      if (/^"<.*?>"/) {
         # Start of a cohort
         if ($in_c) {
            ++$last;
         }
         $cs[$last][0] = $_;
         $cs[$last][1] = '';
         $in_c = 1;
      }
      elsif (/^\t+/ && $in_c) {
         # A reading
         $cs[$last][1] .= "$_\n";
      }
      else {
         # Neither cohort nor reading
         if ($in_c) {
            ++$last;
         }
         $cs[$last][0] = $_;
         $cs[$last][1] = '';
         if (!/^</ && $_) {
            # Not a tag, so give it a null analysis
            $cs[$last][0] = "\"<$_>\"";
            $cs[$last][1] = "\t\"$_\" ?\n";
         }
         ++$last;
         if ($f =~ /^[.]+([ \t]+)$/) {
            $cs[$last][0] = $1;
            $cs[$last][1] = '';
            ++$last;
         }
         $in_c = 0;
      }
   }

   return @cs;
}

sub analyze {
   my ($in) = @_;
   my $out = call_tokenizer($in);

   my @cs = parse_cohorts($out);

   my $did = 1;
   while ($did) {
      $did = 0;

      for (my $i=0 ; $i<scalar(@cs) ; ++$i) {
         # Skip empty lines and tags
         if (!$cs[$i]->[0] || $cs[$i]->[0] =~ /^</) {
            next;
         }

         # Work around HFST bug where abbreviations without space after are misanalyzed
         if (defined $cs[$i+1] && $cs[$i+1]->[0] =~ /^"<\.>"/ && ($cs[$i]->[1] =~ m@ Gram/Abbr\b@ || $cs[$i]->[1] =~ / \?/)) {
            my ($f) = ($cs[$i]->[0] =~ /^"<(.*)>"/);
            my $m = call_tokenizer("$f.");
            if ($m =~ /\t"/ && $m !~ / \?/ && $m =~ /^("<[^\n]*>"[^\n]*)\n(.+)$/s) {
               ($cs[$i]->[0], $cs[$i]->[1]) = ($1, $2);
               splice(@cs, $i+1, 1);
               $did = 1;
               last;
            }
         }

         # Merge sequential dots
         if ($cs[$i]->[0] =~ /^"<([.]+)>"/) {
            my $dots = $1;
            if (defined $cs[$i+1] && $cs[$i+1]->[0] =~ /^"<([.]+)>"/) {
               $dots .= $1;
               $cs[$i]->[0] =~ s/^"<[.]+>"/"<$dots>"/;
               $cs[$i]->[1] =~ s/(\s)"[.]+"/$1"$dots"/g;
               splice(@cs, $i+1, 1);
               $did = 1;
               last;
            }
         }

         if ($cs[$i]->[1] !~ / \?/) {
            next;
         }

         # Work around HFST bug by recursing un-analyzed chunks
         my ($f) = ($cs[$i]->[0] =~ /^"<(.*)>"/);
         my %heur = ();
         my $orig = '';

         my $merge_ncs = sub {
            my ($m) = @_;
            my @ncs = parse_cohorts($m);
            my $h = join(' ', sort(keys(%heur)));
            foreach my $n (@ncs) {
               if ($orig) {
                  $n->[0] =~ s/^("<.*>")/"<$orig>"/;
               }
               if ($h) {
                  $n->[0] =~ s/^("<.*>")/$1 $h/;
               }
            }
            splice(@cs, $i, 1, @ncs);
            $did = 1;
         };

         while (42) {
            # If input has non-alphanumerics, try it again as-is - this catches punctuation
            if ($f =~ /[^\pL\pN\pM]/) {
               my $m = call_tokenizer($f);
               if ($m =~ /\t"[^\n]*"[^?\n]+\n/) {
                  $merge_ncs->($m);
                  last;
               }
            }

            # Split non-alphanumeric from alphanumeric and retry them separately
            if ($f =~ /^([^\pL\pN\pM]+)(.+)$/ || $f =~ /^(.+?)([^\pL\pN\pM]+)$/) {
               my ($f1,$f2) = ($1, $2);
               my $m = call_tokenizer($f1).call_tokenizer($f2);
               if ($m =~ /\t"[^\n]*"[^?\n]+\n/) {
                  $merge_ncs->($m);
                  last;
               }
            }

            # If input might be lacking a -, try with one
            if ($f =~ /^(\p{Lu}+)(\P{Lu}+)$/ && $f !~ /-/) {
               $orig = $orig || $f;
               my $m = call_tokenizer("$1-$2");
               if ($m =~ /\t"[^\n]*"[^?\n]+\n/ && $m !~ /^"<.*?>".*?\n"<.*?>"/s && $m !~ /(?:^|\n)[^\n<>"]+(?:\n|$)/s) {
                  $heur{'Heur/Hyphen'} = 1;
                  $merge_ncs->($m);
                  last;
               }
            }

            # If input doesn't have lower-case letters, try it as first-upper
            if ($f =~ /^[\pL\pN]/ && $f =~ /\p{Lu}/ && $f !~ /\p{Ll}/) {
               $orig = $orig || $f;
               $f = ucfirst(lc($f));
               if ($f ne $orig) {
                  $heur{'Heur/Case'} = 1;
                  my $m = call_tokenizer($f);
                  if ($m =~ /\t"[^\n]*"[^?\n]+\n/) {
                     $merge_ncs->($m);
                     last;
                  }
                  next;
               }
            }

            # If input is first-upper, try it as lower-case
            if ($f =~ /^\p{Lu}\P{Lu}+/ && $f =~ /\p{Ll}/) {
               $heur{'Heur/Case'} = 1;
               $orig = $orig || $f;
               $f = lc($f);
               my $m = call_tokenizer($f);
               if ($m =~ /\t"[^\n]*"[^?\n]+\n/) {
                  $merge_ncs->($m);
                  last;
               }
               next;
            }

            # If input doesn't have upper-case letters, try it as first-upper
            if ($f =~ /^[\pL\pN]/ && $f =~ /\p{Ll}/ && $f !~ /\p{Lu}/) {
               $orig = $orig || $f;
               $f = ucfirst(lc($f));
               if ($f ne $orig) {
                  $heur{'Heur/Case'} = 1;
                  my $m = call_tokenizer($f);
                  if ($m =~ /\t"[^\n]*"[^?\n]+\n/) {
                     $merge_ncs->($m);
                     last;
                  }
                  # This one should not recurse
               }
            }

            last;
         }
      }
   }

   $out = '';
   foreach my $c (@cs) {
      $out .= $c->[0]."\n";
      if ($c->[1]) {
         $out .= $c->[1];
      }
   }

   return $out;
}

my $out = "\"<¶>\"\n\t\"¶\" CLB\n";
my $wf = '';
while (<STDIN>) {
   s/\x{feff}//g; # Unicode BOM

   if (scalar(keys(%cache)) > 10000) {
      %cache = ();
   }

   $out = "\"<¶>\"\n\t\"¶\" CLB\n";
   if (!/^\s*$/) {
      $out = analyze($_);
   }

   my @ls = split(/\n+/, $out, -1);
   foreach (@ls) {
      if ($opt_fst) {
         if (m@^"<(.+)>"@) {
            # Store wordform for later
            $wf = $1;
            print "\n";
            next;
         }
         elsif (m@^\s+"([^\n]+?"?[^"]*)"@) {
            # Turn CG back into FST, protecting baseforms with spaces
            my $b = $1;
            s/^\s+//g;
            s/"\Q$b\E"/XBASEFORMX/;
            s/\s+/+/g;
            s@^(.+)\+Prefix/($pp)@$2+$1@;
            s/XBASEFORMX/$b/;
            # Prepend previously seen wordform
            $_ = "$wf\t$_";
         }
      }
      elsif (m@^\s+"@) {
         # Mark all internal POS tags so they don't confuse the later steps
         while (s@ ($mp|$ap)( .+ (?:$mp)(?: |$))@ $i$1$2@g) {}
      }
      print "$_\n";
   }
}

if ($out ne "\"<¶>\"\n\t\"¶\" CLB\n") {
   if ($opt_fst) {
      print "¶\t¶+CLB\n";
   }
   else {
      print "\"<¶>\"\n\t\"¶\" CLB\n";
   }
}
