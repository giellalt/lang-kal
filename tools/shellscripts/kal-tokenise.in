#!/usr/bin/env perl
# -*- mode: cperl; indent-tabs-mode: nil; tab-width: 3; cperl-indent-level: 3; -*-
use strict;
use warnings;
use utf8;
use FileHandle;
use IPC::Open2;

BEGIN {
	$| = 1;
	binmode(STDIN, ':encoding(UTF-8)');
	binmode(STDOUT, ':encoding(UTF-8)');
}
use open qw( :encoding(UTF-8) :std );
use feature 'unicode_strings';

use Getopt::Long;
Getopt::Long::Configure('no_ignore_case');
my $opt_bin = '';
my $opt_fst = 0;
my $opt_verbose = 0;
my $rop = GetOptions(
	'bin|b=s' => \$opt_bin,
	'fst|f' => \$opt_fst,
	'verbose|v' => \$opt_verbose,
                    );

my @bins = ($opt_bin, '/usr/local/bin/hfst-tokenise', '/opt/local/bin/hfst-tokenise', '/usr/bin/hfst-tokenise');
my $bin = '';
foreach my $f (@bins) {
   if ($f && -x $f) {
      $bin = $f;
      last;
   }
}
if (!$bin || !-x $bin) {
   die("No usable hfst-tokenise given or found!\n");
}
if ($opt_verbose) {
   print STDERR "kal-tokenise: Using ${bin}\n";
}

my $prefix = '@prefix@';
my @fsts = ('', "@datarootdir@/giella/@GTLANG@/tokeniser-disamb-gt-desc.pmhfst", '/usr/local/share/giella/@GTLANG@/tokeniser-disamb-gt-desc.pmhfst', '/usr/share/giella/@GTLANG@/tokeniser-disamb-gt-desc.pmhfst');
if (defined $ARGV[0] && -s $ARGV[0]) {
   $fsts[0] = $ARGV[0];
}
my $fst = '';
foreach my $f (@fsts) {
   if ($f && -s $f && -r $f) {
      $fst = $f;
      last;
   }
}

if (!$fst || !-s $fst) {
   die("No usable tokeniser.pmhfst given or found!\n");
}
if ($opt_verbose) {
   print STDERR "kal-tokenise: Using ${fst}\n";
}

my $t = "${bin} -L ${fst}";

# Prefixes from root.lexc ca. lines 14-15
my @p = ('AA', 'TA');

# Main POS tags from root.lexc ca. lines 19-29
my @m = ('N', 'V', 'Pali', 'Conj', 'Adv', 'Interj', 'Pron', 'Prop', 'Num');

# Other POS tags from root.lexc ca. lines 114-180
my @a = (
   'Sg', 'Du', 'Pl',
   'Abs', 'Rel', 'Trm', 'Abl', 'Lok', 'Aeq', 'Ins', 'Via',
   'Nom', 'Akk',
   'Ind', 'Int', 'Imp', 'Opt', 'Cau', 'Con', 'Par', 'Cont', 'ContNeg', 'IteCau',
   '1Sg', '2Sg', '3Sg', '4Sg', '1Pl', '2Pl', '3Pl', '4Pl', '1Du', '2Du', '3Du', '4Du',
   '1SgO', '2SgO', '3SgO', '4SgO', '1PlO', '2PlO', '3PlO', '4PlO', '1DuO', '2DuO', '3DuO', '4DuO',
   '1SgPoss', '2SgPoss', '3SgPoss', '4SgPoss', '1PlPoss', '2PlPoss', '3PlPoss', '4PlPoss',
   );

my $pp = join('|', @p);
my $mp = join('|', @m);
my $ap = join('|', @a);
my $i = 'i';

open2(*OUT, *IN, $t) or die $!;
binmode(OUT, ':encoding(UTF-8)');
binmode(IN, ':encoding(UTF-8)');
autoflush OUT 1;
autoflush IN 1;

sub analyze {
   my ($in,$n) = @_;
   if (!$n) {
      $n = 0;
   }

   # Give up trying to make sense of input at this point...
   if ($n >= 3) {
      return $in;
   }

   my $nonce = '<nonce-'.rand().'>';
   print IN "$in\n$nonce\n";
   my $out = '';
   while ($out !~ /\Q$nonce\E/) {
      $out .= <OUT>;
   }
   $out =~ s@\Q$nonce\E\s*@@sg;

   # Move prefixes after the base form
   $out =~ s@^(\s+)($pp) (".+?" )@$1$3Prefix/$2 @mg;

   # Special case +URL
   $out =~ s/"\+URL/" URL/g;

   # Remove empty lines, because they were simply spaces in the input
   $out =~ s/\n([\s\t]*\n)+/\n/g;

   # Work around HFST bug where abbreviations without space after are misanalyzed
   # Normalize to a form that happens WITHOUT hyperminimisation
   $out =~ s@( (?:Gram/Abbr|\?)\n)\.\n?@$1"<.>"\n\t"." CLB\n@sg;
   if ($in !~ /^\S+\.$/) {
      $out =~ s@( (?:Gram/Abbr|\?)\n"<\.>"\n\t"\." CLB\n)@$1\x{e000}@sg;
   }
   if ($out =~ /\x{e000}/) {
      my @ms = split(/\x{e000}/, $out);

      foreach my $f (@ms) {
         my ($w) = ($f =~ /"<([^\n]+)>"\n[^<]+"<\.>"\n\t"\." CLB\n$/s);
         if (!$w) {
            next;
         }

         $w .= '.';
         my $m = analyze($w, $n + 1);
         if ($m =~ /\t/) {
            $f =~ s/"<[^\n]+>"\n[^<]+"<\.>"\n\t"\." CLB\n$/$m/s;
         }
      }
      $out = join("\n", @ms);
   }

   # Remove null analysis from tokens to let later steps retry them in pieces
   foreach my $f ($out =~ /(?:^|\n)("<[^\n]+?>"\n\t"[^\n]+?" \?)/g) {
      my ($wf) = ($f =~ /"<([^\n]+?)>"/);
      if ($wf =~ /[^\pL\pN\pM]+/ || $wf =~ /\p{Lu}/) {
         $out =~ s/(^|\n)\Q$f\E(\n|$)/$1$wf$2/g;
      }
   }

   # Work around HFST bug by recursing un-analyzed chunks
   foreach my $f ($out =~ /(?:^|\n)([^<"\t\n][^\n]*)/g) {
      if ($f =~ /^([^\pL\pN\pM]+)(.+?)([^\pL\pN\pM]+)$/) {
         # Split non-alphanumeric from alphanumeric and retry them separately
         my ($f1,$f2,$f3) = ($1, $2, $3);
         my $m1 = analyze($f1, $n + 1);
         my $m2 = analyze($f2, $n + 1);
         my $m3 = analyze($f3, $n + 1);
         if ($f1 ne $m1 || $f2 ne $m2 || $f3 ne $m3) {
            my $m = "$m1\n$m2\n$m3";
            $m =~ s/\n\n+/\n/g;
            $out =~ s/(^|\n)\Q$f\E(\n|$)/$1$m$2/g;
         }
      }
      elsif ($f =~ /^([^\pL\pN\pM]+)(.+)$/ || $f =~ /^(.+?)([^\pL\pN\pM]+)$/) {
         # Split non-alphanumeric from alphanumeric and retry them separately
         my ($f1,$f2) = ($1, $2);
         my $m1 = analyze($f1, $n + 1);
         my $m2 = analyze($f2, $n + 1);
         if ($f1 ne $m1 || $f2 ne $m2) {
            my $m = "$m1\n$m2";
            $m =~ s/\n\n+/\n/g;
            $out =~ s/(^|\n)\Q$f\E(\n|$)/$1$m$2/g;
         }
      }
      elsif ($f =~ /\p{Lu}.*?\p{Lu}/) {
         # If input has multiple upper-case letters, try it as first-upper
         my $m = analyze(ucfirst(lc($f)), $n + 1);
         if ($f ne $m) {
            $m =~ s@" @" Heur/Case @g;
            $m =~ s/"<[^\n]+>"/"<$f>"/;
            $out =~ s/(^|\n)\Q$f\E(\n|$)/$1$m$2/g;
         }
      }
      elsif ($f =~ /\p{Lu}.*?\p{Ll}/ || $f =~ /\p{Ll}.*?\p{Lu}/) {
         # If input is mixed-case, try it as lower-case
         my $m = analyze(lc($f), $n + 1);
         if ($f ne $m) {
            $m =~ s@" @" Heur/Case @g;
            $m =~ s/"<[^\n]+>"/"<$f>"/;
            $out =~ s/(^|\n)\Q$f\E(\n|$)/$1$m$2/g;
         }
      }
      else {
         my $m = analyze($f, $n + 1);
         if ($f ne $m) {
            $out =~ s/(^|\n)\Q$f\E(\n|$)/$1$m$2/g;
         }
      }
   }

   # Work around HFST bug by recursing un-analyzed punctuation
   foreach my $f ($out =~ /(?:^|\n)([^\n\pL\pN\pM]+)(?:\n|$)/g) {
      if ($f =~ /^"<.+?>"$/) {
         next;
      }
      my $m = analyze($f, $n + 1);
      if ($f ne $m) {
         $out =~ s/(^|\n)\Q$f\E(\n|$)/$1$m$2/g;
      }
   }

   return $out;
}

my $wf = '';
while (<STDIN>) {
   my $out = "\"<¶>\"\n\t\"¶\" CLB\n";
   if (!/^\s*$/) {
      $out = analyze($_);
   }

   foreach my $f ($out =~ /(?:^|\n)([^<"\t\n][^\n]*)(?:\n|$)/g) {
      if ($opt_verbose) {
         print STDERR "kal-tokenise: Could not analyse: ${f}\n";
      }
      $out =~ s/(^|\n)[ \t]*([^<"\t\n][^\n]*?)[ \t]*(\n|$)/$1"<$2>"\n\t"$2" ?$3/;
   }

   my @ls = split(/\n+/, $out);
   foreach (@ls) {
      if ($opt_fst) {
         if (m@^"<(.+)>"@) {
            # Store wordform for later
            $wf = $1;
            print "\n";
            next;
         }
         elsif (m@^\s+"([^\n]+?"?[^"]*)"@) {
            # Turn CG back into FST, protecting baseforms with spaces
            my $b = $1;
            s/^\s+//g;
            s/"\Q$b\E"/XBASEFORMX/;
            s/\s+/+/g;
            s@^(.+)\+Prefix/($pp)@$2+$1@;
            s/XBASEFORMX/$b/;
            # Prepend previously seen wordform
            $_ = "$wf\t$_";
         }
      }
      elsif (m@^\s+"@) {
         # Mark all internal POS tags so they don't confuse the later steps
         while (s@ ($mp|$ap)( .+ (?:$mp)(?: |$))@ $i$1$2@g) {}
      }
      print "$_\n";
   }
}
